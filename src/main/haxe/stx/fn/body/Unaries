package stx.fn.body;


/**
  Class for working with Unary Functions.
**/
class Unaries {
  /**
   * Applies the function.
   * @param fn The function  
   * @param p1 The parameter
   * @return Thunk<R>
   */
  static public inline function apply<PI,R>(fn:Unary<PI,R>,v:PI):R{
    return fn(v);
  }
  /**
   * Produces a function that calls `f` with the given parameters `p1....pn`, calls this function only once and memoizes the result.
   * @param fn 
   * @return }
   */
  @:note("those brackets are there to fox the Java compiler")
  static public inline function cache<PI, R>(f: Unary<PI,R>, p1: PI): Thunk<R> {
    var r : R   = null;

    return function() {
      return if (r == null) {
        r = untyped (false);//<--- breaks live lock
        r = f(p1); r;
      }else{
        r;
      }
    }
  }
  /**
		As with lazy, but calls the wrapped function every time it is called.
	**/
  static public inline function pipe<PI, R>(f: Unary<PI,R>, p1: Thunk<PI>): Thunk<R> {
    return function(){
      return f(p1());
    }
  }
  /**
		Compares function identity.
	**/
  static public function equals<PI,R>(a:Unary<PI,R>,b:Unary<PI,R>){
    return Reflect.compareMethods(a,b);
  }
  
  /**
   * Returns a function that applies `fn1` then `fn2` on the input
   * @param fn1 
   * @param fn2 
   * @return PI->R
   */
  static public inline function then<PI,PII,R>(fn1:Unary<PI,PII>,fn2:Unary<PII,R>):Unary<PI,R>{
    return
      function(a:PI):R{
        return fn2(fn1(a));
      }
  }
  
  /**
   * unit function
   * @return Unary<A,A>
   */
  @:noUsing static public function unit<A>():Unary<A,A>{
    return (x:A) -> x;
  }

}
