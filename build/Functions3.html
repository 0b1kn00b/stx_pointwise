package ah.figah.signature;


import haxe.PosInfos;

class Validate{
  /*
  static private function validateCollection(col:Collection,arr:Array<Dynamic>,?pos:PosInfos){
      return
        arr.flatMap(coll.type.validate.bind(_,pos))
      );
    }
  }
  override public function validateField(v:Dynamic,?pos:PosInfos){
    var o = super.validate(v,pos);
    if(this.required){
      if(v == null){
        o.push(Errors.required_field(name,pos));
      }
    }
    o = o.append(type.validate(v,pos));
    return o;
  }

  override public function validateComposite(d:Dynamic,?pos:haxe.PosInfos){
    return super.validate(d).append(
      fields.flatMap(
        function(fld:Field):Array<Error>{
          return fld.validate(Reflect.field(d,fld.name),pos);
        }
      )
    );
  }
  public function validateItem(v:Dynamic,?pos:haxe.PosInfos):Array<Error>{
    return this.validations.map(
      function(x){
        return std.Type.createInstance(std.Type.resolveClass(cast x),[]);
      }
    ).flatMap(
      function(x){
        return x.validate(v);
      }
    );
  }
  public function validateType(v:Dynamic,?pos:haxe.PosInfos):Array<Error>{
    return switch(this){
      case TPrimitive(TInt)     : return_error_if_false("Int",stx.Anys.isInt(v),pos);
      case TPrimitive(TFloat)   : return_error_if_false("Float",stx.Anys.isFloat(v),pos);
      case TPrimitive(TBool)    : return_error_if_false("Bool",stx.Anys.isBoolean(v),pos);
      case TPrimitive(TString)  : return_error_if_false("String",Std.is(v,String),pos);
      case TCollection(c)       : c.validate(v,pos);
      case TComposite(c)        : c.validate(v,pos);
      case TUnknown             : [];
    }
  }
  private function return_error_if_false(type:String,b:Bool,pos:haxe.PosInfos):Array<Error>{
    return if(b){
      [];
    }else{
      [Errors.not_instance_of(type,pos)];
    }
  }
  */
}
